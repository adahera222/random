-- There are some timing related constructs that appear very often 
-- while developing games. One such construct is as follows:
--
-- function update(dt)
--   counter = counter + dt
--   if counter >= action_delay then
--     counter = 0
--     action()
--   end
-- end 
--
-- This performs action() after action_delay seconds.
-- It would be useful to have a function or set of functions that would handle 
-- all that (creating at least two control variables + if + increment) for me.
-- Such function could be defined like this: after(n, action). And so we could 
-- change the code from lines 5-11 to:
--
-- function update(dt)
--   after(action_delay, action()
-- end
--
-- There are other constructs that serve different purposes. Here's a list:
-- (time this function was called = t)
--
-- after(n, action): performs action at time t+n. 
-- until(n, action): performs action every frame until time t+n. 
-- every(n, c, action): performs action at times t+n, t+2n, t+3n, ..., up to c times.
--                      If c is omitted will run until cancelled.
-- cancel(id): removes timer with id = id from the timers list.
--
-- It would also be useful if we could combine after, until and every to create
-- complex timing behaviors. For instance:
--
-- until(5, player.invincility).after(0, player.selfExplosion)
-- The player is invincible for 5 seconds and when that ends he explodes.
-- If it were .after(2, player.selfExplosion) the player would have a 2
-- second delay between invincibility end and self explosion.
-- 
-- every(2, enemy.chooseTarget).after(1, enemy.shoot)
-- The enemy will choose a target every 2 seconds and will shoot
-- 1 second after the every call is cancelled (or until it has been
-- run c times, if c were not omitted).
--
-- There's another possibility:
-- every(2, enemy.chooseTarget).'interleave'.after(1, enemy.shoot)
-- (Can I even do the .'interleave'. part...?)
-- The enemy will choose a target at t = 2 and at t = 3 will shoot.
-- Then it will choose a target at t = 5 and at t = 6 will shoot...
--
-- So, after and until behave as you would expect. Composition makes
-- the actions happen linearly (after action1 is performed, action2
-- will be performed (using the modifiers)). With every that can be
-- the case but it can also be interleaved.
